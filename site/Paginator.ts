import Article from "@element/Article";
import Element, { Initialiser } from "@element/Element";
import Image from "@element/Image";
import BaseNav from "@element/Nav";
import { BLOG_AUTHOR } from "@layout/BlogPage";
import DefaultPage from "@layout/DefaultPage";
import RSSPage from "@layout/RSSPage";
import Files from "@util/Files";
import Log from "@util/Log";
import { HrefLocal } from "@util/string/Strings";
import { PromiseOr } from "@util/Type";
import Page from "site/Page";
import Site from "site/Site";
import trace from "stack-trace";

class Paginator<E extends Element> {

	public static create<E extends Element> (content: readonly PromiseOr<E>[]) {
		return new Paginator(content);
	}

	public constructor (private content: readonly PromiseOr<E>[]) {
	}

	private pageSize = 5;
	public setPageSize (size: number) {
		this.pageSize = Math.max(1, size);
		return this;
	}

	private route?: HrefLocal;
	public setRoute (route: HrefLocal) {
		this.route = route;
		return this;
	}

	private title?: (index?: number) => string[] | undefined;
	public setTitle (titleSupplier: (index?: number) => string[] | undefined) {
		this.title = titleSupplier;
		return this;
	}

	private rss?: true | Initialiser<RSSPage, [readonly E[]]>;
	public setRSS (initialiser?: Initialiser<RSSPage, [readonly E[]]>) {
		this.rss = initialiser ?? true;
		return this;
	}

	public async generate (generator: (content: E[], page: number) => PromiseOr<DefaultPage>) {
		if (!this.route) {
			Log.error(`Ignoring paginator generated by ${Files.loggify(trace.get()[1].getFileName())}, no base route provided`);
			return;
		}

		const content: E[] = (this.content = await Promise.all(this.content));

		let cursor = 0;
		let contentSlice: E[];
		const pages: Page[] = [];
		while ((contentSlice = content.slice(cursor, cursor += this.pageSize)).length) {
			const pageIndex = cursor / this.pageSize;
			const page = await generator(contentSlice, pageIndex);

			const title = this.title?.(pageIndex);
			if (title)
				page.metadata.setTitle(...title);

			pages.push(page
				.main(main => main
					.class("paginated-list")
					.append(...contentSlice)
					.append(new Paginator.Nav(pages, page)
						.setUsePageNumbers()))
				.setRoute(`${this.route}${pageIndex <= 1 ? "" : `/${pageIndex}`}`));
		}

		for (const page of pages)
			await Site.add(page);

		if (this.rss) {
			const page = new RSSPage()
				.setLink(this.route)
				.setAuthor(BLOG_AUTHOR)
				.setRoute(`${this.route}/rss.xml`)
				.metadata.setTitle(...this.title?.() ?? []);

			if (this.rss === true)
				page.addAll(content, (entry, element) => {
					if (!(element instanceof Article))
						return;

					const article = element;
					entry.setTitle(article.title)
						.setLink(article.link as HrefLocal)
						.setPublishedTime(article.publishedTime);
				});

			await Site.add(page.init(this.rss === true ? undefined : this.rss, content));
		}

		return pages;
	}
}

namespace Paginator {

	export class Nav<P extends Page> extends BaseNav {

		public constructor (private readonly over: readonly P[], private readonly current: P, private readonly paginationIndex?: HrefLocal) {
			super();
			this.class("paginator");
		}

		private usePageNumbers = false;
		public setUsePageNumbers () {
			this.usePageNumbers = true;
			return this;
		}

		private reversed?: true;
		public setReversed () {
			this.reversed = true;
			return this;
		}

		public precompile () {
			let prev: P | undefined;
			let next: P | undefined;

			const index = this.over.indexOf(this.current);
			if (index > 0) {
				prev = this.over[index - 1];
			}

			if (index < this.over.length - 1) {
				next = this.over[index + 1];
			}

			if (this.reversed)
				[prev, next] = [next, prev];

			////////////////////////////////////
			// Actually create the buttons
			//

			if (prev) {
				const title = this.usePageNumbers ? `Page ${index}`
					: prev.metadata.title ?? "Previous";
				const linkText = new Element("span")
					.text(`${title} &nbsp;`)
					.append(new Element("span")
						.class("details")
						.text("Previous"));
				this.link(linkText, prev.route ?? "/", link => link
					.class("paginator-prev"));
			}

			if (this.paginationIndex)
				this.link("All", this.paginationIndex, link => link
					.class("paginator-index"));

			if (next) {
				const title = this.usePageNumbers ? `Page ${index + 2}`
					: next.metadata.title ?? "Next";
				const linkText = new Element("span")
					.text(`&nbsp; ${title}`)
					.prepend(new Element("span")
						.class("details")
						.text("Next"));
				this.link(linkText, next.route ?? "/", link => link
					.class("paginator-next"));
			}

			////////////////////////////////////
			// create eoc icon if no more content
			//

			if (!this.children.length) {
				this.type = "footer";
				this.classes.delete("paginator");
				this.append(new Element("p")
					.class("eoc")
					.append(new Image("/static/image/logo.png")
						.attribute("alt", "there is no more content")));
			}
		}
	}
}

export default Paginator;
